---
title:  "포켓몬 파트너 매칭 프로젝트"
excerpt: "1. 포켓몬 상성 계산"

categories:
  - Blog
tags:
  - [Blog, TIL, 생각]

toc: true
toc_sticky: true
 
date: 2021-07-21
last_modified_at: 2021-07-21
---



## 제작 동기

나는 포켓몬스터 게임을 하지 않지만 즐겨보는 사람이다. 포켓몬 배틀 영상을 보던 도중 '철화구야-랜턴' 조합의 포켓몬이 상성이 잘맞아 공생하는 배틀을 보여준 게 인상적이였다.  그래서 나는 포켓몬스터 게임에 존재하는 모든 타입을 조합해 이상적인 포켓몬 파트너 조합을 구하고자 하였다.

## 타입 상성표

![i16246145733](https://user-images.githubusercontent.com/76248669/126361024-74513612-4c6e-4726-aaac-115ff4350d67.png)

(8세대 기준)현재까지 나온 포켓몬 타입은 18가지이고, 포켓몬 당 최대 2가지 타입을 가질 수 있다.

따라서 타입 가짓수는 18 + 18 * 17 / 2 = 171가지이며 밸런스 등의 문제 때문에 17가지 타입이 구현되지 않아 실제로는 153가지 타입 개수가 구현되어 있다.

```python
pokeDefense = {
    # 단일 타입 18가지
    '노말': [1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    '격투': [1, 1, 1, 1, 2, 0.5, 0.5, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0.5, 2],
    '독': [1, 0.5, 0.5, 2, 1, 0.5, 1, 1, 1, 1, 1, 1, 0.5, 1, 2, 1, 1, 0.5],
    '땅': [1, 1, 0.5, 1, 1, 1, 0.5, 1, 1, 1, 2, 0, 2, 2, 1, 1, 1, 1],
    '비행': [1, 0.5, 1, 0, 1, 0.5, 2, 1, 1, 1, 1, 2, 0.5, 2, 1, 1, 1, 1],
    '벌레': [1, 0.5, 1, 0.5, 2, 1, 2, 1, 1, 2, 1, 1, 0.5, 1, 1, 1, 1, 1],
    '바위': [0.5, 2, 0.5, 2, 0.5, 1, 1, 1, 2, 0.5, 2, 1, 2, 1, 1, 1, 1, 1],
    '고스트': [0, 0, 0.5, 1, 1, 0.5, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
    '강철': [0.5, 2, 0, 2, 0.5, 0.5, 0.5, 1, 0.5, 2, 1, 1, 0.5, 0.5, 0.5, 0.5, 1, 0.5],
    '불꽃': [1, 1, 1, 2, 1, 0.5, 2, 1, 0.5, 0.5, 2, 1, 0.5, 0.5, 1, 1, 1, 0.5],
    '물': [1, 1, 1, 1, 1, 1, 1, 1, 0.5, 0.5, 0.5, 2, 2, 0.5, 1, 1, 1, 1],
    '전기': [1, 1, 1, 2, 0.5, 1, 1, 1, 0.5, 1, 1, 0.5, 1, 1, 1, 1, 1, 1],
    '풀': [1, 1, 2, 0.5, 2, 2, 1, 1, 1, 2, 0.5, 0.5, 0.5, 2, 1, 1, 1, 1],
    '얼음': [1, 2, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 1, 0.5, 1, 1, 1, 1],
}
```

일단 타입 상성표를 ```iterable``` 하게 만들기 위해서 dictionary로 제작하였다.

index는 key 타입을 순서대로 공격하였을 때 몇 배 대미지가 들어가는 지를 적어두었다.

0: 노말, 1:격투, 2:독...... 17:페어리

ex> `pokeDefense['바위'][3] ` :  바위 타입을 땅타입을 가격하였을 때 대미지 배수





멀티 타입일 경우에는 이렇게 계산한다.

포켓몬 타입이 물 비행인 포켓몬이 전기타입 기술을 맞았을 때

물타입은 전기 2배, 비행타입도 전기 2배이므로 물 2배 대미지 * 비행 2배 대미지 = 4배 를 입게 된다.



포켓몬 타입이 물 드래곤이 얼음타입 기술을 맞았을 때

물타입은 얼음 0.5배, 드래곤 타입은 2배 대미지를 입으므로

0.5 * 2 = 1배 대미지를 입게 된다.



```python
def weaknessPrint(userText: list[str]) -> None: # 타입1, 타입2를 입력하면 상성표를 출력
    answer = {}

    if len(userText) == 1: # 단일타입 계산
        for i in range(18):
            answer[reverse_pokenum[i]] = pokeDefense[userText[0]][i]
    else:    
        for i in range(18): # 멀티타입 계산
            answer[reverse_pokenum[i]] = pokeDefense[userText[0]][i] \
                * pokeDefense[userText[1]][i]
    
    # answer(dict)를 value를 기준으로 내림차순 정렬해 list로 저장
    answer = sorted(answer.items(), reverse=True, key=lambda item: item[1])
    
    # 출력
    print("< ", end="")
    for i in userText:
        print(i, end=" ")
    print("상성 >")
    for i in answer:
        print("{} : {}배".format(i[0], i[1]))
```



약점 `list`를 출력해주는 함수 제작

```python
def weakness(userText): # 약점 list를 return
    return pokeDefense[userText[0]] if len(userText) == 1 \
    else [(pokeDefense[userText[0]][i] * pokeDefense[userText[1]][i]) for i in range(18)]
```

```'노말': [1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]``` 의 value처럼 `list`를 만들어 주는 함수



`weakness` 함수에 `['강철', '비행']`을 넣었다고 가정해보자. 그렇다면 나오는 `list`는

```python
[0.5, 1.0, 0, 0, 0.5, 0.25, 1.0, 1, 0.5, 2, 1, 2, 0.25, 1.0, 0.5, 0.5, 1, 0.5]
```

여기서 약점인 인덱스만 추출하는 함수를 만든다.

index별로 무슨 타입인지 약속했기 때문에 인덱스로만 이루어진 리스트를 보내도 된다.

```python
# weakness list를 입력하면 약점 index를 return
def weaknessIndex(userText: list[int]) -> list[int]:  
    return [i for i, ele in enumerate(userText) if ele >= 2]

# 타입을 입력하면 약점 index를 return
def strengthIndex(userText: list[str]) -> list[int]:  
    return [i for i, ele in enumerate(weakness(userText)) if ele <= 0.5]
```

